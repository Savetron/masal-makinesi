import Foundation
import Security

// MARK: - Authentication Manager

/// Manages JWT authentication and token lifecycle
@available(iOS 15.0, macOS 12.0, *)
@MainActor
public final class AuthenticationManager: ObservableObject {
    
    // MARK: - Properties
    
    /// Current authentication state
    @Published public private(set) var isAuthenticated: Bool = false
    
    /// Current user ID (extracted from JWT)
    @Published public private(set) var currentUserId: String?
    
    /// Current JWT token
    private var currentToken: String? {
        didSet {
            Task {
                await updateAuthenticationState()
            }
        }
    }
    
    /// Keychain service identifier
    private let keychainService = "com.masalmakinesi.auth"
    private let tokenKey = "jwt_token"
    
    // MARK: - Singleton
    
    public static let shared = AuthenticationManager()
    
    private init() {
        Task {
            await loadStoredToken()
        }
    }
    
    // MARK: - Public Methods
    
    /// Set authentication token (e.g., from Sign in with Apple)
    public func setToken(_ token: String) async {
        await storeToken(token)
        currentToken = token
        await updateAuthenticationState()
    }
    
    /// Get current valid token for API requests
    public func getValidToken() async -> String? {
        guard let token = currentToken else { return nil }
        
        // Check if token is still valid
        if await isTokenValid(token) {
            return token
        }
        
        // Try to refresh token if needed
        // Note: In production, implement token refresh logic here
        return nil
    }
    
    /// Sign out and clear authentication
    public func signOut() async {
        await clearStoredToken()
        currentToken = nil
        currentUserId = nil
        isAuthenticated = false
    }
    
    /// Create test token for development
    public func createTestToken(userId: String = "test-user", email: String = "test@example.com") async -> String? {
        // This would only work in development environment
        // In production, tokens come from Sign in with Apple or backend
        
        let _: [String: Any] = [
            "userId": userId,
            "email": email,
            "iat": Date().timeIntervalSince1970,
            "exp": Date().addingTimeInterval(24 * 60 * 60).timeIntervalSince1970 // 24h expiry
        ]
        
        // In a real app, this would be generated by the backend
        // For testing, we'll create a mock token
        let testToken = "test.\(userId).\(Int(Date().timeIntervalSince1970))"
        
        await setToken(testToken)
        return testToken
    }
    
    // MARK: - Private Methods
    
    /// Load token from keychain on app launch
    private func loadStoredToken() async {
        if let token = await getStoredToken() {
            currentToken = token
            await updateAuthenticationState()
        }
    }
    
    /// Update authentication state based on current token
    private func updateAuthenticationState() async {
        guard let token = currentToken else {
            isAuthenticated = false
            currentUserId = nil
            return
        }
        
        if await isTokenValid(token) {
            isAuthenticated = true
            currentUserId = extractUserId(from: token)
        } else {
            isAuthenticated = false
            currentUserId = nil
            // Clear invalid token
            await clearStoredToken()
            currentToken = nil
        }
    }
    
    /// Check if JWT token is valid (not expired)
    private func isTokenValid(_ token: String) async -> Bool {
        // Parse JWT token and check expiry
        // For demo purposes, basic validation
        guard !token.isEmpty else { return false }
        
        // In production, properly decode JWT and check expiry
        // For now, assume test tokens are valid for 24h
        if token.hasPrefix("test.") {
            return true // Test tokens are always valid for demo
        }
        
        // TODO: Implement proper JWT validation
        return true
    }
    
    /// Extract user ID from JWT token
    private func extractUserId(from token: String) -> String? {
        // Parse JWT payload and extract userId
        // For demo purposes with test tokens
        if token.hasPrefix("test.") {
            let components = token.components(separatedBy: ".")
            return components.count > 1 ? components[1] : "test-user"
        }
        
        // TODO: Implement proper JWT payload parsing
        return "demo-user"
    }
}

// MARK: - Keychain Storage

extension AuthenticationManager {
    
    /// Store token securely in keychain
    private func storeToken(_ token: String) async {
        let data = token.data(using: .utf8)!
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey,
            kSecValueData as String: data
        ]
        
        // Delete existing item first
        SecItemDelete(query as CFDictionary)
        
        // Add new item
        let status = SecItemAdd(query as CFDictionary, nil)
        if status != errSecSuccess {
            print("Failed to store token in keychain: \(status)")
        }
    }
    
    /// Retrieve token from keychain
    private func getStoredToken() async -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var dataTypeRef: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
        
        guard status == errSecSuccess,
              let data = dataTypeRef as? Data,
              let token = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        return token
    }
    
    /// Clear token from keychain
    private func clearStoredToken() async {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey
        ]
        
        SecItemDelete(query as CFDictionary)
    }
}

// MARK: - Auth State

/// Authentication state for SwiftUI views
public enum AuthState {
    case loading
    case authenticated(userId: String)
    case unauthenticated
    
    public var isAuthenticated: Bool {
        switch self {
        case .authenticated: return true
        case .loading, .unauthenticated: return false
        }
    }
} 